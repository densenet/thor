export type Code<T = string | any> = T
export type Kernel<T> = {
  __mul: Code<T>,
  __pow: Code<T>,
  __concat: Code<T>,
  __mod: Code<T>,
  __unm: Code<T>
}
export type Signature = {
  Unit: dim,
  Anti: dim,
  Null: dim,
}

-- idx: the 1-indexed position in an array-based multivector in which a multivector component exists
type idx = number
-- grade_idx: the 1-indexed position of the nth grade word in a list of all grade words. node n starts from zero. this is generally n+1
type grade_idx = number
-- word: the bit representation of a multivector component basis.
--       bit words have a intuitive & concise 1-1 correspondence: on bit refers to presence of a wedged basis vector
type word = number
-- grade_word: similar to word, except represents all grades in the multivector which do not have all components zero.
--             a multivector in 4D which only consists of a sum of vectors has a grade word 0b01000.
type grade_word = number
-- positive integer representing signature dimensions
type dim = number

-- output generated by generate_sigmap_tables
type GradeMaps = {
  GRADE_IDX_TO_FIRST_IDX: { [grade_idx]: idx },
  IDX_TO_GRADE_WORD: { [idx]: grade_word },
  WORD_TO_IDX: { [word]: idx },
  IDX_TO_WORD: { [idx]: word }
}

type HandlerState = { term_ct: number, term_buf: { Code<string> } }

-- specification for function generators which incrementally build cayley tables for kgen
type ProductHandler = 
  (state: HandlerState, D: dim, DU: dim, DA: dim, DN: dim) ->
    (bw_i: word, bw_j: word, i: idx, j: idx) -> ()

-- special case of above for automorphisms e.g. dual, reversion, conjugate, respectively for mgen
type MutateHandler = (state: HandlerState, D: dim, DU: dim, DA: dim, DN: dim) ->
    (bw: word, i: idx) -> ()

local MAX_D = 16

local BINC, inc_word
if script then
  local util = script.Parent.util  
  
  BINC, inc_word = require(util.binc), require(util.inc_word)
else
  BINC, inc_word = require("src\\util\\binc"), require("src\\util\\inc_word")
end
BINC = BINC(MAX_D)

--local bit2str = require("src\\util\\bit2str")

local b, x, l, n, r = bit32.btest, bit32.bxor, bit32.lshift, bit32.bnot, bit32.rshift
local rz = bit32.countrz

local get_clifford_sigmaps
do
  local function generate_sigmap_tables(D: dim): any
    local gi2i = table.create(D + 2)
    local fr = table.freeze
    
    -- generate the map that takes grade index to first grade-associated MV component index
    -- if the grade is N, it will return the component index of e_0^e_1^...*e_(N-1)
    do
      local t = gi2i
      t[1] = 1
      
      for k = 1, D + 1 do
        t[k + 1] = BINC[D + 1][k] + t[k]
      end
      
      fr(t)
    end
    
    -- generate the map that takes MV component index to associated grade word
    local i2gw = {}
    do
      local t = i2gw
      
      for k = 1, D + 1 do
        for i = gi2i[k], gi2i[k + 1] - 1 do
          t[i] = l(1, k - 1)
        end
      end
      
      fr(t)
    end
    
    -- generate the map that takes MV component basis word to respective MV component index, and the reverse map
    local w2i, i2w = {}, {}
    do
      local t, u = w2i, i2w
      
      local i = 1
      local w = 0
      repeat
        t[w], u[i] = i, w
        w = inc_word(w, D)
        i += 1
      until w == 0
      
      fr(t); fr(u)
    end
    
    return gi2i, i2gw, w2i, i2w
  end 
  
  local function f(sig: Signature): GradeMaps
    local gi2i, i2gw, w2i, i2w = generate_sigmap_tables(sig.Null + sig.Unit + sig.Anti)
    
    return {
      GRADE_IDX_TO_FIRST_IDX = gi2i,
      IDX_TO_GRADE_WORD = i2gw,
      WORD_TO_IDX = w2i,
      IDX_TO_WORD = i2w
    }
  end
  
  get_clifford_sigmaps = f
end

local function get_prod_term_sign(DU: dim, DA: dim, DN: dim, bw_i: word, bw_j: word): number
  local retsign = 1

  local D0, D1, D2 = DN, DU + DN, DU + DN + DA
  
  -- cobw gives us information about which basis vectors are shared in the MV component basis word
  local cobw = bit32.band(bw_i, bw_j)
  
  -- null signature short-circuit:
  -- if any two null signature elements are multiplied, we get wedge product case: it eliminates the product term
  for pos = 0, D0 - 1 do
    if b(cobw, l(1, pos)) then
      return 0
    end
  end
  -- sign produced by reducing (bw_i,bw_j) to product basis
  -- follows fundamental rules of multiplying two MV component bases: eliminate the shared bases, flip on the non-shared bases
  -- inlined version of ./util/eps.luau
  do
    local acc = false
    local negate = false
    for i = D2 - 1, 1, -1 do
      acc = if b(bw_i, l(1, i)) then not acc else acc
      if b(bw_j, l(1, i - 1)) and acc then
        negate = not negate
      end
    end
    retsign = if negate then -retsign else retsign
  end
  -- anti signature bookkeeping: just have to flip signs if two basis vectors annihilate
  for pos = D1, D2 - 1 do
    if b(cobw, l(1, pos)) then
      retsign = -retsign
    end
  end

  return retsign
end

local function inc_word_gated(bw: word, D: dim, gate: grade_word, grade: grade_idx): (word, grade_idx)
  bw = inc_word(bw, D)
  if rz(n(bw)) == grade then
    while true do
      grade += 1
      if not b(gate, l(1, grade)) then
        return bw, grade
      end
      bw = n(l(n(bw), 1))
    end
  else
    return bw, grade
  end
  return 0, D + 2
end

local function expand(D: dim, gate: grade_word, cb: (word, word) -> (), cb2: (word) -> ())
  local bw_A, bw_B = 0, 0
  
  local gate_B = r(gate, 5)
  
  local grade_A: grade_idx, grade_B: grade_idx = 1, 1
  repeat
    bw_B = 0
    repeat
      cb(bw_A, bw_B)
      
      bw_B, grade_B = inc_word_gated(bw_B, D, gate_B, grade_B)
      
      --[=[
      if rz(n(bw_B)) == grade_B then
        while true do
          grade_B += 1
          if not b(gate, l(1, D + grade_B)) then
            break
          end
          bw_B = n(l(n(bw_B), 1))
        end
      end]=]
    until bw_B == 0 or grade_B > D + 1
    cb2(bw_A)
   
    bw_A = inc_word(bw_A, D)
  until bw_A == 0 or grade_A > D + 1
end

local function replace(D: dim, gate: grade_word, cb: (word) -> ())
  local bw = 0
  
  local grade: grade_idx = 1
  repeat
    cb(bw)
    
    bw, grade = inc_word_gated(bw, D, gate, grade)
  until bw == 0
end

local f = string.format
local function kgen(KGEN_ENV, handler: ProductHandler): Code<string>
  local state = {
    term_ct = 0,
  }
  local D: dim = KGEN_ENV.D
  local SIGMAP: GradeMaps = KGEN_ENV.SIGMAP
  local sig: Signature = KGEN_ENV.Signature
  local gate: grade_word = KGEN_ENV.Gate
  
  local IDX2GW = SIGMAP.IDX_TO_GRADE_WORD
  local WORD2I = SIGMAP.WORD_TO_IDX
  
  local term_buf: { Code<string> } = table.create(#IDX2GW)
  state.term_buf = term_buf
  
  local gen = handler(state, D, sig.Unit, sig.Anti, sig.Null)
  
  local k_buf: { Code<string> } = table.create(#IDX2GW)
  
  expand(D, gate, function(bw_i: word, bw_j: word)
    local j: idx = WORD2I[bw_j]
  
    -- initially, bw_i is actually the product's output basis word
    -- reverse calculate which bw_i would need to be lhs for a given rhs bw_j to get bw_i as product basis word
    bw_i = x(bw_i, bw_j) :: word
    -- "_swp" encodes the trick we did above. it's the multivector component index of calculated bw_i
    local i_swp: idx = WORD2I[bw_i]
    

    local i_gw: grade_word = IDX2GW[i_swp]

    if b(gate, i_gw) then
      --print("p", bit2str(gate), bit2str(i_gw))
      return -- case: gate says left multiplicand's current grade should be all zero
    end
    
    gen(bw_i, bw_j, i_swp, j)
  end, function(tg_i)
    if state.term_ct > 0 then
      local i: idx = WORD2I[tg_i]
      
      -- product term, composed of all relevant term entries
      k_buf[#k_buf + 1] = f("t[%d]=%s", i, table.concat(term_buf))
      
      table.clear(term_buf)
      
      state.term_ct = 0
    end
  end)
  
  return table.concat(k_buf, "\n")
end

local function geo_prod_handler(state, D, DU, DA, DN)
  return function(bw_i, bw_j, i, j)
    local sign: number = get_prod_term_sign(DU, DA, DN, bw_i, bw_j)
    if sign == 0 then
      return -- case: some common multivector component had a null basis vector
    end
    
    state.term_ct += 1
    
    -- term entry
    state.term_buf[state.term_ct] = f("%sa[%d]*b[%d]", if sign == 1 then if state.term_ct > 1 then "+" else "" else "-", i, j)
  end
end

local function wedge_prod_handler(state, D, ...)
  return function(bw_i, bw_j, i, j)
    local sign: number = get_prod_term_sign(0, 0, D, bw_i, bw_j)
    if sign == 0 then
      return
    end
    
    state.term_ct += 1
    
    state.term_buf[state.term_ct] = f("%sa[%d]*b[%d]", if sign == 1 then if state.term_ct > 1 then "+" else "" else "-", i, j)
  end
end

local function _stub(): Code<string>
  return ""
end

local STDSIG = {
  -- complex numbers i^2=-1
  c   = ":,1",
  -- hyperbolic numbers i^2=1
  hyp = ":1",
  -- dual numbers i^2=0
  d   = ":,,1",
  -- quaternions
  quat  = ":,2",
  -- 3D plane-based geometric algebra
  pga3d = ":3,,1",
  -- 3D conformal geometric algebra
  cga3d = ":4,1",
  -- octonions
  octo  = ":,3",
  -- dual quaternions
  dquat = ":,2,1",
}


local _dynsig_cache: { [string]: Signature } = {}
local function parse_dynsig(body: string): Signature
  if _dynsig_cache[body] then
    return _dynsig_cache[body]
  end
  
  local scheme, args = body:split(":")
  
  if args == nil then
    error("invalid signature: could not find a 'scheme:args' separator ':'")
  end
  
  if scheme == "" then
    
  elseif scheme == "dual" then
    
  end

  error(f("invalid signature: scheme '%s' is unknown", scheme))
end


-- signature: specifies exactly the outcome of multiplying basis elements
--            the primary {Unit,Anti,Null} design is in regard to Clifford algebra conventions

-- gate: bitmask of size 2D+2 which represents two juxtaposed grade bases
--       the D+1 lsbs is a left multiplier, and D+1 msbs right multiplier
--       for automorphisms, only the D+1 lsbs are considered
--       the mask marks respective (k-1)-blades of the input MV as expected to be ZERO
--       this results in a considerable performance boost

local function genkernel(_signature: (Signature | string), _gate: grade_word?): Kernel<string>
  local gate = if _gate then _gate else 0
  
  local sig: Signature = if typeof(_signature) == "string" then parse_dynsig(STDSIG[_signature] or _signature) else _signature

  local DU, DA, DN = sig.Unit, sig.Anti, sig.Null
  local D = DU+DA+DN
  if D > MAX_D then
    error(f("a sig with total dimension greater than 8 is not supported; got (%d, %d, %d)", DU, DA, DN))
  end
  if DU % 1 ~= 0 or DA % 1 ~= 0 or DN % 1 ~= 0 then
    error(f("a sig can't be composed of fractional numbers; got (%.2f, %.2f, %.2f)", DU, DA, DN))
  end
  if DU < 0 or DA < 0 or DN < 0 then
    error(f("a sig must be composed of non negative numbers; got (%d, %d, %d)", DU, DA, DN))
  end
  
  local kernel = {}
  
  do
    local SIGMAP: GradeMaps = get_clifford_sigmaps(sig)
    
    local KGEN_ENV = {
      D = D,
      SIGMAP = SIGMAP,
      Signature = sig,
      Gate = gate
    }
  
    kernel.__mul = kgen(KGEN_ENV, geo_prod_handler) -- GEOMETRIC PRODUCT
    kernel.__pow = kgen(KGEN_ENV, wedge_prod_handler) -- WEDGE PRODUCT / MEET
    kernel.__concat = _stub() -- REGRESSIVE PRODUCT / JOIN
    kernel.__len = _stub() -- MV DUAL
    kernel.__unm = _stub() -- UNARY MINUS
    kernel.__mod = _stub() -- SANDWICH PRODUCT (A % B == B * A * B.r)
  end

  return kernel :: Kernel<string>
end

do
  local k = genkernel("quat", 0)
  
  print(k.__mul)
  print(k.__pow)
end

--[=[

]=]

--return genkernel
