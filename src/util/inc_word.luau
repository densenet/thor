local b, x, l, n = bit32.btest, bit32.bxor, bit32.lshift, bit32.bnot
local lz, rz, repl = bit32.countlz, bit32.countrz, bit32.replace

export type word = number
export type dim = number

local function inc_word(w: word, D: dim): word
  -- want to swap most significant (0,1) pair, as long as there's no bit at Dth bit.
  -- if at Dth bit:
  --  * slide Dth bit and all adjacent on-bits up to first (0,1) pair
  --  * swap aforementioned (0,1) pair
  --  if no (0,1) pair exists, slide to almost-LSB & turn on LSB
  if w == 0 then
    return 1
  elseif n(l(-1, D)) == w then
    return 0
  end

  local adj_w: word = l(w, 32 - D)

  -- case: Dth bit on 
	if b(adj_w, 0x80000000) then
    local l1ct: dim = lz(n(adj_w))
    local r0ct: dim = rz(w)
  
    -- case: (0,1) pair exists
    if r0ct + l1ct ~= D then
      -- this is how many zeroes there are beyond the 1s subword
      local l0ct: dim = lz(l(adj_w, l1ct))
      -- this is the position of 1 in the (0,1) pair. it must be swapped
      local off: dim = l1ct+l0ct+1
    
      return x(
        -- right-slid Dth 1s
        l(n(l(-1, l1ct)), D - off+2),
        -- swap
        repl(w, 0b10, D - off, off))
    end
  
    -- case: no (0,1) pair in word    
  
    return n(l(-1, l1ct+1))
  end

  local l0ct: dim = lz(adj_w)

  return repl(w, 0b10, D - (l0ct+1), 2)
end

--[=[
local function _dbgout_inc_word(dbgparams)
  local bit2str = require("src\\util\\bit2str")
  
  local t = {}

  local i = 0
  repeat
    local j = inc_word(i, dbgparams.D)
    t[#t + 1] = string.format("\n%s", bit2str(j))
    i = j
  until i == 0

  print(table.concat(t))
end


_dbgout_inc_word({
  D = 8
})
]=]

--[=[
D = 4 output:
00000001
00000010
00000100
00001000
00000011
00000101
00001001
00000110
00001010
00001100
00000111
00001011
00001101
00001110
00001111
00000000

D = 8 output:
00000001
00000010
00000100
00001000
00010000
00100000
01000000
10000000
00000011
00000101
00001001
00010001
00100001
01000001
10000001
00000110
00001010
00010010
00100010
01000010
10000010
00001100
00010100
00100100
01000100
10000100
00011000
00101000
01001000
10001000
00110000
01010000
10010000
01100000
10100000
11000000
00000111
00001011
00010011
00100011
01000011
10000011
00001101
00010101
00100101
01000101
10000101
00011001
00101001
01001001
10001001
00110001
01010001
10010001
01100001
10100001
11000001
00001110
00010110
00100110
01000110
10000110
00011010
00101010
01001010
10001010
00110010
01010010
10010010
01100010
10100010
11000010
00011100
00101100
01001100
10001100
00110100
01010100
10010100
01100100
10100100
11000100
00111000
01011000
10011000
01101000
10101000
11001000
01110000
10110000
11010000
11100000
00001111
00010111
00100111
01000111
10000111
00011011
00101011
01001011
10001011
00110011
01010011
10010011
01100011
10100011
11000011
00011101
00101101
01001101
10001101
00110101
01010101
10010101
01100101
10100101
11000101
00111001
01011001
10011001
01101001
10101001
11001001
01110001
10110001
11010001
11100001
00011110
00101110
01001110
10001110
00110110
01010110
10010110
01100110
10100110
11000110
00111010
01011010
10011010
01101010
10101010
11001010
01110010
10110010
11010010
11100010
00111100
01011100
10011100
01101100
10101100
11001100
01110100
10110100
11010100
11100100
01111000
10111000
11011000
11101000
11110000
00011111
00101111
01001111
10001111
00110111
01010111
10010111
01100111
10100111
11000111
00111011
01011011
10011011
01101011
10101011
11001011
01110011
10110011
11010011
11100011
00111101
01011101
10011101
01101101
10101101
11001101
01110101
10110101
11010101
11100101
01111001
10111001
11011001
11101001
11110001
00111110
01011110
10011110
01101110
10101110
11001110
01110110
10110110
11010110
11100110
01111010
10111010
11011010
11101010
11110010
01111100
10111100
11011100
11101100
11110100
11111000
00111111
01011111
10011111
01101111
10101111
11001111
01110111
10110111
11010111
11100111
01111011
10111011
11011011
11101011
11110011
01111101
10111101
11011101
11101101
11110101
11111001
01111110
10111110
11011110
11101110
11110110
11111010
11111100
01111111
10111111
11011111
11101111
11110111
11111011
11111101
11111110
11111111
00000000


]=]

return inc_word
