-- @densenet
-- mathloader (3rd variant)

-- this variant emits bitcode with indices embedded like mathloader
-- loadkernel decomposes it into easy access arrays at load time, instead of runtime like mathloader2

-- mathloader
-- a string loader for stringified geometric algebra kernels, generated by thor
-- the input code needs to be conformal to the model below:
-- rules: <subexp> = <"a["<number>"]*b["<number>"]">
--				<exp> = <subexp> <<"+"|"-"><subexp>>*
-- given the rules above, the source can be expressed:
--[=[
<"t["<index>"]="<expansion>>*
]=]
-- notice that an initial term has no sign
-- this is a small oversight that is nevertheless not important for the domain mathloader is intended for


local n, x, l, r = bit32.bnot, bit32.bxor, bit32.lshift, bit32.rshift

local repl, band = bit32.replace, bit32.band

type u32 = number
type bitcode = { u32 }

local function compile(idxwidth: u32, src: string): bitcode
		-- 0: exit
	-- 1: t[.]=a[.]*b[.] (assignmulaccess)
	-- 2: +a[.]*b[.] (plusmulaccess)
	-- 3: -a[.]*b[.] (submulaccess)
	
	-- instructions are 2 bits
	-- indices are idxwidth bits, must be a multiple of two.
	
	if idxwidth % 2 ~= 0 then
		error("idxwidth must be an even number")
	end
	
	local program = {0}
	
	do
		local SIZE_IN = #src
		local ptr = 1
		local ins_ptr = 1
		local ins_depth = 0
		
		local function push(width: u32, chunk: u32)
			local fragment = 0
			repeat
				fragment = math.min(32 - ins_depth, width)
				
				program[ins_ptr] = repl(program[ins_ptr], band(chunk, n(l(-1, fragment))), ins_depth, fragment)
				
				chunk = r(chunk, fragment)
				
				ins_depth += fragment
				
				if ins_depth == 32 then
					ins_depth = 0
					ins_ptr += 1
					program[ins_ptr] = 0
				end
				
				width -= fragment
				
				if width < 0 then
					error("width underflow")
				end
				if ins_depth > 32 then
					error("ins_depth overflow")
				end
				if fragment <= 0 then
					error("fragment is not a positive number")
				end
			until width == 0
		end
		
		local byte	
		local function parse_index()
			local num = 0
			repeat
				byte = string.byte(src, ptr) - 48
				if byte > 9 or byte < 0 then
					error(string.format("nan: %s; ptr: %d", string.char(byte + 48), ptr))
				end
				num = num * 10 + byte
				ptr += 1
			until string.byte(src, ptr) == 93
			push(idxwidth, num - 1)
		end
		
		-- instruction loop	
		while ptr < SIZE_IN do
			byte = string.byte(src, ptr)
			if byte == 116 then
				push(2, 1)
				ptr += 2
				parse_index()
				ptr += 4
				parse_index()
				ptr += 4
				parse_index()
				ptr += 1
			elseif byte == 43 then
				push(2, 2)
				ptr += 3
				parse_index()
				ptr += 4
				parse_index()
				ptr += 1
			elseif byte == 45 then
				push(2, 3)
				ptr += 3
				parse_index()
				ptr += 4
				parse_index()
				ptr += 1
			elseif byte == 10 then
				ptr += 1
			else
				error(string.format("syntax error: %x (%s)", byte, string.char(byte)))
			end
		end
	end
	
	return program
end

local function loadkernel(idxwidth: u32, raw: bitcode): ({ number }, { number }, { number }) -> ()
	--local program: bitcode = {}
	local index0: { u32 } = {}
	local index1: { u32 } = {}
	local index2: { u32 } = {}
	
	-- load
	do
		local RAWSIZE = #raw
		local ins_ptr = 1
		local ins_depth = 0
		
		local function pop_index(): u32
			local readw = idxwidth
	
			local idx = 0
			repeat
				local fragment = math.min(32 - ins_depth, readw)
		
				idx = repl(idx, bit32.extract(raw[ins_ptr], ins_depth, fragment), idxwidth - readw, fragment)
		
				readw -= fragment
		
				ins_depth += fragment
		
				if ins_depth == 32 then
					ins_ptr += 1
					ins_depth = 0
				end
		
			until readw == 0
	
			return idx + 1
		end
		
		while ins_ptr <= RAWSIZE do
			local ins = bit32.extract(raw[ins_ptr], ins_depth, 2)
			
			ins_depth += 2
			if ins_depth == 32 then
				ins_depth = 0
				ins_ptr += 1
			end			

			if ins == 1 then
				index0[#index0 + 1] = pop_index()
				index1[#index1 + 1] = pop_index()
				index2[#index2 + 1] = pop_index()
			elseif ins == 2 then
				index0[#index0 + 1] = 0
				index1[#index1 + 1] = pop_index()
				index2[#index2 + 1] = pop_index()
			elseif ins == 3 then
				index0[#index0 + 1] = -1
				index1[#index1 + 1] = pop_index()
				index2[#index2 + 1] = pop_index()
			else
				break
			end
		end
	end
	
	-- procedure
	local DATASIZE = #index0
	return function(t,a,b)
		local t_idx = 0
		local acc = 0
		
		local i0, i1, i2 = 0, 0, 0
		
		for i = 1, DATASIZE do
			i0, i1, i2 = index0[i], index1[i], index2[i]
			
			if i0 == 0 then
				acc+=a[i1]*b[i2]
			elseif i0 == -1 then
				acc-=a[i1]*b[i2]
			else
				t[t_idx] = acc
				acc, t_idx = 0, i0
				acc+=a[i1]*b[i2]
			end
		end
		if t_idx then
			t[t_idx] = acc
		end
	end
end

--[==[
local kpga3d = loadkernel(4, { 
	0xce228001,0x99e23448,0x45eeeab,0x36896108,0xd8f52d1e,0x79ce2f74,0xaf27b8eb,
	0x89febbfd,0x98e22080,0xbb94e0f4,0x8c0cdeae,0xa4a8c22,0xe9a939ea,0xeb29c111,
	0x92a3b408,0x155e8e8e,0x3b88612c,0x9a250932,0xf97e1b79,0xeb12b3ab,0x99fafb7d,
	0x18af13c1,0x8258d363,0x9fa167a9,0xb3bb2e9f,0xdf9bb2d4,0xcb314c1d,0xb59d063d,
	0x5a3f709a,0xbbea9a9,0xf8fafd3f,0xca23c221,0x9aa024e8,0x265e4aa7,0x428fb24c,
	0xea290a2b,0x2e82a9e3,0xe26438d3,0xde2a8298,0x89b1882e,0xb5393e35,0xda067ed8,
	0x2ab0ab39,0xf4f9ed9f,0x9f198331,0x549163fc,0xa3772dba,0x2baeae91,0x3b9bd8b0,
	0xe1a8375f,0xed1a37cb,0x3273d925,0xb9a869be,0xf96d0b23,0x2a83b9f2,0xe12488e7,
	0xde0a8a93,0xcb61ec3f,0x75a92e3c,0x6e1e789a,0xeb4e969,0xf0b86d2f,0x0})

local __SANITY = false

if __SANITY then
	local t = table.create(16, 0)
	local a = table.create(16, 0)
	local b = table.create(16, 0)
	
	for i = 2, 5 do
		a[i], b[i] = math.random(), math.random()
	end
	
	kpga3d(t, a, b)
	
	for i = 1, 16 do
		t[i] = string.format("%.2f", t[i])
	end
	
	print("--", table.concat(t, ","))
end
--	0.97,0.00,0.00,0.00,0.00,0.20,0.26,0.41,0.14,0.25,0.05,0.00,0.00,0.00,0.00,0.00
--	0.40,0.00,0.00,0.00,0.00,0.26,0.60,-0.04,0.07,-0.07,-0.16,0.00,0.00,0.00,0.00,0.00

local __TIMING = false

if __TIMING then
	local t = table.create(16, 0)
	local a = table.create(16, 0)
	local b = table.create(16, 0)
	
	for i = 2, 5 do
		a[i], b[i] = math.random(), math.random()
	end
	
	local stamp = os.clock()
	
	for i = 1,1e4 do
		kpga3d(t, a, b)
	end
	
	print(string.format("--%.3fms", 1e3*(os.clock()-stamp)))
end
--68.081ms
-- timing with naive zero guard:
--63.832ms
-- with this new runtime, we get merely 3X above loadstring timing without zero guards!
-- now let's check with a dense multivector (although, we did run without zero guards)

local __TIMING_DENSE = false

if __TIMING_DENSE then
	local t = table.create(16, 0)
	local a = table.create(16, 0)
	local b = table.create(16, 0)
	
	for i = 1, 16 do
		a[i], b[i] = math.random(1000) - 500, math.random(1000) - 500
	end
	
	local stamp = os.clock()
	
	for i = 1,1e4 do
		kpga3d(t, a, b)
	end
	
	print(string.format("--%.3fms", 1e3*(os.clock()-stamp)))
	
	for i = 1, 16 do
		t[i] = string.format("%.2f", t[i])
	end
	
	print("--", table.concat(t, ","))	
end
-- 67.437ms
-- we're definitely working with something good here.
-- dense timing with naive zero guard:
-- 88.754ms
-- in this case, it might be profitable to simply give up the zero guard
-- we have the grade gate in the case of our GA kernel
]==]


local __RELEASE = true
if __RELEASE then
	return {
		compile = compile,
		loadkernel = loadkernel
	}
end
